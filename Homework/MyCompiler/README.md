#CPSL

This is an implementation of a compiler for the CPSL (Compiler Project Source Language) language, a toy language designed for the CS5300 Compilers course at Utah State University. The language is a "strongly  typed,  static  scoped,  block  structured,  high  level language in the spirit of Pascal" (quoted from the language specification document). The language's full specifications, detailing its syntax, structure, and features, can be found on the Github page for the class [here](https://github.com/ksundberg/CS5300/blob/master/CPSL.tex). This compiler compiles CPSL code into MIPS assembly code, which can then be run on any MIPS processor or emulator. It was written in C++, using the Bison parser and Flex scanner.

##Using the compiler

###Dependencies
The following dependencies are necessary to run the compiler, as well as the produced MIPS code:

- gcc 7.3
- flex 2.6
- bison 3.0.4
- cmake 3.9
- MARS 4.5

###Running the compiler
The compiler is expected to be run from the command line. To build the compiler, navigate to the main directory, then run `cmake .`, followed by `make`. This will generate a `cpsl` executable in the main directory, which can then be run.

This compiler reads the CPSL program from stdin and outputs MIPS to stdout. As such, it is recommended that the user redirect stdin and stdout to point towards their CPSL file and the output MIPS file, respectively. For example, to compile `my_cpsl_program.cpsl` into `my_mips_program.asm`, run `./cpsl <my_cpsl_program.cpsl >my_mips_program.asm`. A set of example CPSL files can be found in the `examples` directory, demonstrating how the language handles expressions, control statements, data structures, and functions.

##Glossary
This paper assumes a certain knowledge of concepts specific to compilers and assembly. As such, a quick definition of terms is in order before we proceed.

- **Symbol Table**: The symbol table is a map from strings to the locations in memory they represent. This is how the compiler knows to replace `my_var` with the value in memory we actually want to use in some calculation. Because CPSL supports scope (regions of code outside of which a variable is no longer recognized), the symbol table is implemented as an list of maps. When a scope is entered, a new map is pushed onto the symbol table. When the scope is exited, this map is popped off (rendering any variables in it inaccessible). There are three ways types of scope in CPSL: the global scope (whose variables are declared and entered at the beginning of the program), for loop scope (which declares the incrementing/decrementing variable), and function scope (which declares the function's variables). At the beginning of the program, `true`, `false`, `TRUE`, and `FALSE` are entered into the symbol table, alongside the expected boolean values.
- **Type Table**: The type table does what the symbol table does, but for types. Primitive types (characters, ints, and booleans) are entered by default, before the program begins scanning and parsing. Custom types are entered into the TypesTable in the type declaration block at the start of the program. Custom types can simply be renamed primitive types (for example, renaming `integer` to `number`), records (also known as structs in other languages), and arrays.
- **String Table**: This does what other tables do, but for strings and their labels. Strings are associated with a label, which enables them to be referenced in the program. At the end of the program, the labels are printed out alongside their associated string.
- **Function Table**: The function table associates the function's string representation with their function prototype. The function prototype contains the label associated with the start of the function in the assembly, the types of the arguments it expects, and the return type of the function. The function table is used whenever a function is called in the program.
- **Register Pool**: The register pool ensures that registers are not used for contradicting purposes. In assembly, there are only 32 registers available for the program, of which only 16 are available for normal usage. While this is plenty for normal operations, it is important that different operations don't overwrite the value in the registers between operations. As such, the register pool functions as a simple list with all the available registers in it at the start of the program. When a register is needed, a register is popped off the list; when it's no longer needed, the register is returned.
- **Global Pointer ($gp)**: This points to the start in memory allocated to the program. This is where variables stored in the global scope are stored.
- **Stack Pointer($sp)**: This points to the end of memory allocated to the program (the start of the stack). This is used to keep track of where we can store function parameters, and moves as memory is pushed onto and popped off the stack.
- **Frame Pointer ($fp)**: This points to the start of the memory allocated to a function's parameters and local variables. Because the stack pointer can move, having a frame pointer ensures we have consistent offsets to access function parameters and variables.

##How the Compiler Works
The compiler begins in `main.cpp`. Here, it creates a global value for the tables used by the compiler, as well as the register pool. It then inserts the predefined values needed for the type table (the primitive types) and the symbol table ("true" and "false" are assigned the applicable BOOLEAN values). From here, it calls `yyparse`, which starts the scanning and parsing section of the compiler.

###Scanning and Parsing
The first step taken by the compiler is to scan the given file and replace the text with tokens that can be more reliably used by the parser. This is done with Flex in `my_scanner.l`, which searches for text patterns with regex, and returns tokens for matches. It scans for keywords first (for example, "if" would be replaced by an IF_TOKEN), then operators ("+" replaced with ADD_TOKEN), then the more general ids, strings, and numbers, whose values are stored using the `yylval` tool. These tokens are then sent to the parser.

The parser takes the tokens and verifies that they form a valid CPSL program, then transforms the tokens into a Program. This compiler uses Bison, and does the parsing in `my_parser.y`. A program is effectively a tree of statements and expressions, which provides an order in which the MIPS code can be emitted. If the tokens provided do not form a valid CPSL program, the parser will throw a syntax error, along with the line number the syntax error was on. If they do form a valid program, a tree will be constructed, and then code will be emitted.

The parser uses Bison to recognizing patterns in tokens. Each value in Bison is defined by a series of patterns. There can be many definitions for a single value in Bison. For example, an "lvalue"* matches on `ID_TOKEN` (what we would think of as a normal variable, ie `mystruct.a`), on `lvalue PER_TOKEN ID_TOKEN` (which would be a value in a record), and on `lvalue LBRAC_TOKEN expr RBRAC_TOKEN` (which would be a value of an array, ie `myarray[1]`). The recursive nature of Bison allows for simple but inclusive declarations of matching. For example, `a.b[1].c.d[2][3]` matches as a valid lvalue, even with the simple rules laid out above.

Every value is associated with a Bison type with a %type declaration (for example, `ID_TOKEN`s are assigned `stringVal`, `expr`s are assigned `expr`, etc). Each Bison type is in turn associated with a C++ type in the %union block (for example, `stringVal` is a `char*`, `expr` is an `Expression*`)  This enables the program to turn the tokens into C++ classes that are able to emit the necessary code. For example, an lvalue matched on `ID_TOKEN` passes the `ID_TOKEN`'s string representation to the new `LvalueExpression` constructed and returned, while an `expr` matched on `expr ADD_TOKEN expr` returns a new `AddExpression` with the two arguments.

After the program is parsed, code is emitted. The remainder of this section will focus on what is necessary to emit code for the various features of the language.

\* "lvalue" is short for "left value". A left value is any value in the program that can be on the left side of an assignment statement. Any value associated with a location in memory is an lvalue.


###Compiling simple programs

####Emitting simple expressions
An Expression is anything that evaluates to a value. Valid expressions include numerical constants, string constants, char constants, arithmetic and boolean operations, lvalues, and function calls. Function calls and more complicated lvalues will be described in their own section, but the rest are generally included in the category of "simple expressions".

Numerical constants are simple to emit. We return an `ExpressionResult` with the constant int value. In a naive implementation, we would emit `"li $register $int_val"` to load the int value into a register. However, doing so too early can lead to a case where a very long arithmetic expression runs out of registers and is unable to compute the value (see `examples/simple_expressions/long_expressions.cpsl` for an example of such a case). Instead, we pass on the constant value and only load it into a register immediately before evaluation. This is done in the `load_int` function in `UsefulFunctions`, which is called by `get_reg_from_result` in `UsefulFunctions`. This function is used in most arithetic expressions, ensuring that registers are conserved properly. Because char constants are able to be loaded into memory, they are treated almost identically to numerical constants. Because constants are declared at the start of the program, we can treat them the same as we as numerical or char constants, rather than having to 

String constants are the only valid form of strings in CPSL, meaning that strings cannot split, concatenated, or otherwise modified. As such, strings are effectively only used by WriteStatements. All string constants in the program are put into the string table, where they are associated with a label. The label is then returns, for usage by whatever called the emit. At the end of the program, the string table emits the MIPS code that associates all strings with a label.

Simple lvalues are simply `ID_TOKEN`s that have been associated with a spot in memory. This association is saved in the `SymbolTable`. To load the lvalue, the MIPS code `lw $ret_reg, $offset($base_reg)` is emitted. The `base_reg` (for simple lvalues, this is simply the global pointer) tells the program where to start counting from. The `offset` is added to the `base_reg` to reach the desired location in memory. `lw` loads whatever is at the indicated location in memory into `ret_reg`. Like with constants, loading the value into memory is deferred until the last moment, to save registers until when they are needed. Because memory can only be modified by statements, we are assured that the value at that location in memory will not be modified between expression emission and expression usage by a parent expression or statement.

All arithmetic and boolean expressions function in a conceptually identical way. An expression will have its sub expressions emit the code necessary (remember that these sub expressions may be numerical constants). It will then check that the types of the sub expressions. If they do not match, an error is thrown; otherwise, it will load the sub expressions values into registers, as well as reserving a register for the result. Then, it emits the MIPS code necessary to complete the expression (for example, `AddExpression` emits `add $ret_reg, $left_reg, $right_reg`). The registers used for the arguments are then returned to the register pool. The register is then returned in an `ExpressionResult`, so that it may be used by the statement or expression that fired the `emit` function.

An optimization utilized by this compiler's expressions is constant folding. If both of an expression's sub expressions are constant, the relevant operations are done at compile time, rather than at run time. This enables an expression like `1+2+3+4+5+6` to be reduced to `21` at run time, which is much more efficient to execute both in terms of run time and registers.

####Emitting simple statements
Assign statements are given an `LvalueExpression` and an `Expression`. The expression is emitted, then the expression's type is compared to the lvalue's type. If they are different, a type error is thrown. Otherwise, as long as the lvalue is a simple lvalue, the register containing the expression's value is saved to the lvalue's location in memory with `sw $reg_to_save, $offset($base_reg)`. Saving into arrays and record is described in their own section.

Write statements are given a list of expressions. These expressions are emitted, have their values loaded into `reg`, and then print sequentially. 
- If the expression is a string constant, `li $v0, 4` is emitted, which tells the MIPS processor that `la` should print strings. `la $a0 $reg` is emitted, which prints the string label stored in the `reg`.
- If the expression is an int or a bool, `li $v0,1` is emitted, which tells the MIPS processor should print ints. `move $$a0, reg` is emitted, which prints an int.
- Printing a char is identical to printing an int, except that `li $v0,1` is replaced with `li $v0,11`, which tells the processor to interpret the register as a char.

Read statements are given a list of lvalues. Each lvalue is emitted, then has its location in memory assigned to whatever the user types in. This is done through `li $v0,5` or `li $v0,12` (depending on whether the lval was a char or an int), then `syscall`, then `sw $v0, $offset($base_reg)`.

####Emitting a simple program
A simple program consists of variable declaration, then a list of statements (see `/examples/simple_expressions/expressions.cpsl` for an example). The variables are read, recorded into the symbol table, and assigned a location in memory at the beginning of the program; dynamically assigned memory is not supported by CPSL. The main program is parsed as a `statement_seq`, which is executed in order. At the end of the program, the string table is emitted, which contains the string labels that allow the program to print its string constants.

###Handling Custom Types (Records and Arrays)
Custom types are entered into 

####Records
Every record type has a list of ids, each of which is associated with a particular offset into the base lvalue's location in memory. This association is recorded in a symbol table, a smaller version of the symbol table of the entire program. An individual record has a base lvalue, which tells the compiler where its reservation in memory begins. At compile time, the offset into the record is added to the offset of the base lvalue. So, for example, if `my_variable` was a record starting 16 bytes into memory, with `int a, b` (each taking up four bytes) as its attributes, a call to `my_variable.b` would load the value located 20 bytes into memory. Because these calculations are known at compile time, there is no run time cost to accessing a value in a record, compared to a simple variable. Assigning into a record works the same way, except that the offset into memory is saved into instead of loaded from.

####Arrays
An array has a base lvalue, as well as an expression which represents the offset into memory as an int. The first step to evaluating the array is to emit the expression that represents its index. Once this is done, we subtract the array's lower bound* from the expression register. We then multiply our offset by the size of the objects in the array (for a standard int, this would be by 4), to get the offset into memory we want. Now that we have our offset, we add it to the global pointer (which tells us where memory starts), to get the absolute location in memory desired. Now, finally, we load the value from memory, like we would with a simple variable. Assigning into a record works the same way, except that the offset into memory is saved into instead of loaded from.

As should be clear from the aboe description, loading a value from an array has a significant overhead, compared to loading from a simple variable. Because the language supports dynamic expressions as the offset into the array, we cannot make assumptions about what location in memory we'll access at compile time. One optimization available, not implemented by this compiler, is to recognize constant indexes, and replace them with a simple `lw` from the proper location in memory.

\* arrays in CPSL have user defined spans. For example, an array[5:7] would have access memory with `a[5]`, `a[6]`, and `a[7]`, and would have 5 subtracted from the expression to bound it properly.

###Control flow
####While Loops
A while loop is the simplest method of control flow to implement in assembly. A while loop consists of a boolean expression, as well as a list of statements. First, a label is printed out at the start of the loop. Then, the boolean expression is emitted. If the register equals 0, the assembly will jump to a label at the end of the while loop (as yet unwritten). The statements within the while loop are emitted. At the end of the statements, a jump command to the beginning of the loop is emitted. Finally, the end label is emitted. Though simple, this is sufficient to set up a while loop in assembly.

Because each label must be unique, the WhileStatement has a global value that is added to the end of the label. This value is incremented after every while statement, to ensure the labels are unique. 

####Repeat Loop
A repeat loop (also known as a "do-while" loop) functions identically to a while loop, except that the boolean expression is emitted and evaluated after the statement sequence, instead of before. The primary consequence of this is that the statements are guaranteed to be run at least once before the loop is broken out of.

####For Loop
A for loop consists of a string identifying its variable, an expression with that variable's initial value, an expression with the loop's end value, an enum telling us if the loop increments or decrements (user defined operations are not supported by CPSL, only incrementing and decrementing), and a sequence of statements. For loops are the only way to declare a variable that isn't in the scope of the entire program. As such, before any code is emitted, we enter a new scope with the global symbol table. Once the new scope is entered, the for loop's variable is entered into the SymbolTable, and the initial value is emitted and saved to the associated location in memory (the same way it would be in a simple AssignStatement). 

Once the init value is assigned, the head label is emitted, followed by the boolean expression. A `beq` command is emitted, which will jump the program to the end of the loop if the boolean expression evaluates to zero. Next, the statements are emitted in order. The increment/decrement expression for the loop variable is emitted, after which a jump command sends the program to the beginning of the loop. Finally, the end label is printed. At this point, the for loop's scope is exited, which prevents the loop's variable from being referenced later on in the program.

This compiler contains no protections against modifying the for loop variable, nor does it protect against infinite loops (for example, an incrementing loop that's waiting to reach a negative number). As such, it is entirely possible, and actually quite easy, to give the compiler a for loop that will never end.

This compiler also does not implement the common optimization of loop unfurling. Because for loops are more predictable than other types of loop at compile time, and because for loops impose an overhead on the instructions performed (jump and `beq` commands are not free, after all), it is common for more sophisticated compilers to detect loops "unfurl" them, by simply repeating the statement sequence however many times the loop would repeat (along with the increment/decrement expression). This increases the size of the executable produced, while counterintuitively producing a faster program.

####If Statements
Despite being perhaps the most intuitive control structure to explain to new programmers, an if/else if/else block is the most complicated control structure to implement in a compiler. Each individual  `IfStatement` simply evaluates its boolean statement. If it evaulates to zero, the if statement jumps to the next if statement (via a label given to it by the large `IfBlockStatement`). If not, the statement sequence is evaluated, then a jump command to the end of the block is emitted (the end label is also given by the larger if block). Finally, at the end, it emits the label for the next if statement.

The `IfBlockStatement` creates a `next_label` and an `end_label`, which is passed to the `IfStatement`s that make up the block. First, the initial if statement is emitted. Then, in a for loop over the if else statements, the `next_label` is incremented and the next if statement is emitted. Finally, the else statement is emitted (if one exists). Because an else statement doesn't need a boolean statement to evaluate, it simply emits a sequence of statements (all the control statements should be handled by the previous if statements).

###Functions
####Function declaration
To declare a function, we must have the id representing the function, a list of the params (containing their id token and their type), the return type of the function, and finally the body of the function (which has the variables declared in the function, as well as a statement list). First, we must add the function to the function table (so that func calls can access the label that starts the function). Then, we enter a new scope, set the offset to the size of the return type (so that we have room to store the return value at the frame pointer), and add the params to the symbol table (offset from the frame pointer). After args are entered, we must reset the offset into the frame pointer (so that future recursive calls have a clean slate). We then emit the label marking the start of the function, and emit the body.

The body first adds the local variables to the symbol table (offset from the stack pointer). Then, the size of the local variables are subtracted from the stack pointer, so that it continues to point to empty memory. The stack pointer offset is then reset (these steps are important for recursive function calls, since the frame pointer is set to the stack pointer when a function is called). The statement list is then emitted. If the function has a return statement, the return statement will save the return value into the frame pointer's location, then jump to the epilogue label. After the statements are emitted, the epilogue must be printed. The epilogue starts with the epilogue label, followed by a command that adds the size of the local variables back to the stack pointer, and finally a jump return call, which jumps to the value stored in `$ra` (which should be the location that called the function).

####Function calls
A function call can occur both as an expression and a standalone statement. First, the state of the program must be saved onto the stack. All registers used for normal operations, as well as the frame pointer and the return pointer, must be saved to the stack (the frame pointer and return pointer are important for recursive functions). Then, the arguments (each of which is an expression) are loaded into a register, then those registers are saved to the stack (larger custom types, such as arrays, are loaded one byte at a time, since loading an entire array into registers is a good way to run out of registers). The size of the arguments and the spilled registers is then added to the stack pointer, and the frame pointer is set to the stack pointer. At this point, a `jal` call is made, which jumps to the function label and saves the current spot of the program into the return pointer (so that execution may be resumed after the function completes). Once the function completes, the registers are loaded again from from the stack, and the value at the frame pointer is loaded into a register (this retrieves the return value of the function). Finally, the memory used for the registers is returned to the stack pointer, and the register with the return value is returned.

As should be clear from the above description, calling a function has a significant runtime cost. One common optimization, not implemented by this compiler, is to inline small functions (so, copy the statements of the function to the point of the code that calls it). This means the program can skip saving the state and the jump commands, which can be significantly more efficient. However, for large functions, the benefits are minimal, and the size increase to the executable is significant. As such, heuristics are important to determine when inlined functions make sense.

